name: Sync Upstream, Validate Links, and Push to TVB

# å®šæ—¶ä»»åŠ¡ï¼šæ¯éš”ä¸€å¤©è¿è¡Œä¸€æ¬¡
on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 */2 * *'

jobs:
  sync_validate_push:
    runs-on: ubuntu-latest
    
    # å®šä¹‰è¦æ“ä½œçš„ä»“åº“ä¿¡æ¯
    env:
      FORK_REPO: ${{ github.repository_owner }}/Tvbox1  # ä½ çš„Forkä»“åº“è·¯å¾„
      UPSTREAM_REPO: hd9211/Tvbox1 # æºä»“åº“è·¯å¾„
      TARGET_REPO: ${{ github.repository_owner }}/tvb # ç›®æ ‡ç§æœ‰ä»“åº“è·¯å¾„

    steps:
      - name: 1. Checkout YOUR FORK Repository (Tvbox1)
        uses: actions/checkout@v4
        with:
          # ä½¿ç”¨ PAT_FOR_FORK æ¥è®¿é—®å’Œä¿®æ”¹ä½ çš„ Tvbox1 Fork
          token: ${{ secrets.PAT_FOR_FORK }}
          repository: ${{ env.FORK_REPO }}
          path: fork-repo # ç­¾å‡ºåˆ° 'fork-repo' ç›®å½•

      - name: 2. Setup Git User in Fork Repo
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

      - name: 3. Sync from Upstream
        id: sync_step
        working-directory: ./fork-repo # åœ¨ä½ çš„Forkä»“åº“ç›®å½•ä¸­æ‰§è¡Œ
        run: |
          # æ·»åŠ æºä»“åº“
          git remote add upstream https://github.com/${{ env.UPSTREAM_REPO }}.git
          git fetch upstream
          
          # æ£€æŸ¥æ›´æ–°
          LOCAL=$(git rev-parse @)
          REMOTE=$(git rev-parse upstream/main)
          
          if [ "$LOCAL" = "$REMOTE" ]; then
            echo "âœ… Fork is up-to-date. No new commits from upstream."
            echo "HAS_UPDATES=false" >> $GITHUB_ENV
          else
            echo "ğŸ”¥ Upstream has updates. Syncing..."
            # å¼ºåˆ¶åŒæ­¥å¹¶æ¨é€åˆ°ä½ çš„ Fork
            git reset --hard upstream/main
            git push origin main --force
            echo "HAS_UPDATES=true" >> $GITHUB_ENV
          fi

      # -------------------------------------------------------------------
      # åç»­æ­¥éª¤ä»…åœ¨æœ‰æ›´æ–°æ—¶æ‰§è¡Œ
      # -------------------------------------------------------------------

      - name: 4. Setup Python
        if: env.HAS_UPDATES == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: 5. Install Python Dependencies
        if: env.HAS_UPDATES == 'true'
        run: pip install requests

      - name: 6. Create Validation Script
        if: env.HAS_UPDATES == 'true'
        run: |
          # è„šæœ¬å†…å®¹ä¸å˜ï¼Œä»ç„¶åˆ›å»ºåœ¨Actionçš„æ ¹å·¥ä½œç›®å½•
          cat << 'EOF' > validate_links.py
          import json
          import requests
          import sys
          import os
          from concurrent.futures import ThreadPoolExecutor

          HEADERS = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'}
          TIMEOUT = 8

          def check_url(url):
              # ... (Python è„šæœ¬ä»£ç ä¸å˜ï¼Œä¸ºèŠ‚çœç©ºé—´çœç•¥ï¼Œè¯·ä½¿ç”¨ä¹‹å‰å®Œæ•´çš„ä»£ç ) ...
              if not url or not url.startswith(('http://', 'https://')):
                  print(f"SKIPPING: Invalid URL format {url}")
                  return False, url
              try:
                  response = requests.get(url, timeout=TIMEOUT, headers=HEADERS, allow_redirects=True, stream=True)
                  if 200 <= response.status_code < 400:
                      print(f"SUCCESS: {url} (Status: {response.status_code})")
                      return True, url
                  else:
                      print(f"FAIL: {url} (Status: {response.status_code})")
                      return False, url
              except requests.RequestException as e:
                  print(f"ERROR: {url} ({e})")
                  return False, url

          def process_file(filepath):
              if not os.path.exists(filepath):
                  print(f"File not found: {filepath}. Skipping.")
                  return

              print(f"\nProcessing file: {filepath}")
              try:
                  with open(filepath, 'r', encoding='utf-8') as f:
                      data = json.load(f)
              except Exception as e:
                  print(f"Error reading or decoding {filepath}: {e}")
                  return

              key_list = None
              if 'sites' in data and isinstance(data['sites'], list):
                  key_list = 'sites'
              elif 'urls' in data and isinstance(data['urls'], list):
                  key_list = 'urls'
              else:
                  print(f"Unknown JSON structure in {filepath}. Skipping.")
                  return
              
              items = data.get(key_list, [])
              urls_to_check = []
              for item in items:
                  if isinstance(item, dict):
                      url = item.get('url') or item.get('api')
                      if url:
                          urls_to_check.append((url, item))
                      else:
                          print(f"SKIPPING item: No 'url' or 'api' key found in {item}")

              if not urls_to_check:
                  print(f"No URLs found to check in {filepath}.")
                  return

              valid_items = []
              with ThreadPoolExecutor(max_workers=10) as executor:
                  results = executor.map(check_url, [u[0] for u in urls_to_check])
                  
                  for (is_valid, url), item in zip(results, [u[1] for u in urls_to_check]):
                      if is_valid:
                          valid_items.append(item)

              data[key_list] = valid_items
              try:
                  with open(filepath, 'w', encoding='utf-8') as f:
                      json.dump(data, f, ensure_ascii=False, indent=4)
                  print(f"Processed {filepath}. Kept {len(valid_items)} / {len(items)} items.")
              except Exception as e:
                  print(f"Error writing processed file {filepath}: {e}")

          if __name__ == "__main__":
              files_to_process = sys.argv[1:]
              if not files_to_process:
                  print("No files specified.")
                  sys.exit(1)
              
              for f in files_to_process:
                  process_file(f)
          EOF


      - name: 7. Run Validation Script (on Fork files)
        if: env.HAS_UPDATES == 'true'
        run: |
          # ä» fork-repo ç›®å½•è¯»å–æ–‡ä»¶ï¼Œåœ¨ Action æ ¹ç›®å½•è¿è¡Œè„šæœ¬
          python validate_links.py fork-repo/ä¼˜è´¨.json fork-repo/cr.json fork-repo/duocang1.json

      - name: 8. Checkout Private Repo 'tvb'
        if: env.HAS_UPDATES == 'true'
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_FOR_TVB }} 
          repository: ${{ env.TARGET_REPO }}
          path: tvb-repo
          
      - name: 9. Copy Filtered Files
        if: env.HAS_UPDATES == 'true'
        run: |
          # ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨ï¼ˆè§£å†³ä¸Šæ¬¡çš„é”™è¯¯ï¼‰
          echo "Ensuring target directory exists..."
          mkdir -p tvb-repo/tvb/TVbox/
          
          echo "Copying validated files to tvb-repo/tvb/TVbox/..."
          # æ³¨æ„ï¼šç°åœ¨æºæ–‡ä»¶è·¯å¾„æ˜¯ fork-repo/...
          cp fork-repo/ä¼˜è´¨.json tvb-repo/tvb/TVbox/
          cp fork-repo/cr.json tvb-repo/tvb/TVbox/
          cp fork-repo/duocang1.json tvb-repo/tvb/TVbox/
          
      - name: 10. Commit and Push to 'tvb'
        if: env.HAS_UPDATES == 'true'
        run: |
          cd tvb-repo
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          if [ -n "$(git status --porcelain)" ]; then
            git add .
            git commit -m "chore: Auto-update and validate Tvbox sources"
            git push
            echo "âœ… Successfully pushed validated files to tvb repo."
          else
            echo "â„¹ï¸ No changes to commit."
          fi
